*** Dynamic Programming ***
## 理论基础 ##
    动态规划是自底向上地解决问题
    动态规划通过将复杂问题拆解成较小且重复的子问题来解决问题，每个子问题只解决一次，并将结果存储在一个表格中
    ❗️动态规划中每一个状态一定是由上一个状态推导出来的❗️
    * Diff w Greedy *
        贪心也是局部直接选最优的，但是Greedy没有状态推导

## Steps ##
    一定要按照这五步做，会更简单:
        1.确定dp数组以及下标的含义
        2.确定递推公式/状态转移方程
        3.dp数组如何初始化
        4.确定遍历顺序
        5.举例推导dp数组验证状态前4步

## Topic Summary ##
    #1.背包问题#
        1.1.概述
          ├── 背包
          │   └── 最大容量 W
          └── 物品
              ├── 价值 v[]
              ├── 体积 w[]
              └── 每个物品的数量
                  ├── 只有一个
                  │   ├── 不选
                  │   └── 选一个
                  │       └── 0/1 背包
                  └── 无数个
                      ├── 不选
                      └── 选几个
                          └── 完全背包
        1.2.背包问题的遍历顺序
            遍历顺序包括: 双重循环内外次序; 单个循环的遍历顺序;
            1.01Bags二维dp: 内外循环顺序都行;
                            内循环正序;
            2.01Bags一维dp: 内外循环顺序先物品再容量;
                            内循环倒序;
                                  1.倒序会让第i-1层的值得到保留;01背包问题需要上一层(i-1)的dp[j]的值(从二维数组的递推公式看出来)
                                  2.倒序能保证物品i只被放入一次;因为01背包中所有的物品只能使用一次
            3.CompleteBags二维dp: 内外循环顺序都行;
                                  内循环正序;
            4.CompleteBags一维dp: 内外循环顺序看情况;
                                        1.如果求组合数就是外层for循环遍历物品，内层for遍历背包 P518
                                        2.如果求排列数就是外层for遍历背包，内层for循环遍历物品 P377
                                  内循环正序;
                                        1.不需要倒序;完全背包问题不需要上一层(i-1)的dp[j]的值(从二维数组的递推公式看出来)
                                        2.不能倒序;正序使得每次装物品都允许多次使用同一物品,完全背包中的物品可以被使用无限次

        1.3.递推公式/状态转移
            1.问能否能装满背包(或者最多装多少):
                  dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
                  P416 P1049
            2.问装满背包有几种方法:
                  dp[j] += dp[j - nums[i]]
                  P494, P518, P377, P70
            3.问背包装满最大价值:
                  dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
                  P474
            4.问装满背包所有物品的最小个数:
                  dp[j] = min(dp[j - coins[i]] + 1, dp[j]);
                  P322, P279
        1.4.例题
            01Bags:
                P416: 求给定背包容量，能不能装满这个背包
                P1049: 求给定背包容量，尽可能装，最多能装多少容量
                P494: 求给定背包容量，装满背包有多少种方法
                P474: 求给定背包容量，装满背包最多有多少个物品
            CompleteBags:
                P518: 求总金额为j的物品组合个数；如果求组合数就是外层for循环遍历物品，内层for遍历背包
                P377: 求nums和为target的排列数；如果求排列数就是外层for遍历背包，内层for循环遍历物品
                P322: 求背包容量为amount时，最少需要多少个coins
                P279: 求背包容量为n时，最少需要多少个perfect nums

        1.5.其他
            看到sum和array同时出现，就可以考虑是不是能用背包做

    #2.拆数问题#
        例题
            P96 P343
            (完全背包问题) P279 P322 P518
    #3.强盗问题#
        总结：选择问题(抢/不抢)->递推公式
        例题：P198, P213, P337

    #4.股票问题#
        总结：声明状态(暗含选择问题:买/不买；卖/不卖)->状态转移
        例题：P121, P122, P714, P309, P123, P188

    #5.子序列问题#
        5.1.不连续子序列问题 P300 P1143 P1035
                Keywords: Subsequence
                解题思路:
                    不连续子序列的跟前0-i个状态有关
                    不连续的子序列的dp[]定义一般是以按照长度来，比如dp[i][j]是0->i长度的nums1和0->j长度的nums2的最长LCS
        5.2.连续子序列问题 P674 P718 P53
                Keywords: Continues Subsequence/ Subarray
                解题思路：
                    连续的子序列只跟前一个状态有关
                    连续子序列的dp[]定义一般是以nums[i]为结尾
        5.3.(两个对象的子序列问题) P718 P1143 P1035
        5.4.编辑距离
            定义:
                Edit Distance/Levenshtein Distance，是指两个字符串之间通过插入、删除或替换字符，将一个字符串转换成另一个字符串所需的最少操作次数
            例题：
                P392: (只对t进行删除操作)给定字符串s和t判断s是否为t的子序列
                P115: (只对t进行删除操作)给定一个字符串s和一个字符串t，计算在s中子序列为t的个数
                P583: (可以对s和t进行删除操作)给定两个单词s和t，找到使得s和t相同所需的最少操作数，每次操作可以删除任意一个字符串中的一个字符
                P72:(对s进行插入删除替换操作)你两个单词s和t，请你计算出将s转换成t所使用的最少操作数
            总结：
                1.明确dp[i+1][j+1]的含义
                      根据题意来，但是i+1和j+1肯定是s和t的前i长度和前j长度
                      这里必须是i+1和j+1，对应s中的第i个char和t中的第j个char，这样处理更方便
                2.判断s[i] ?= t[j]
                3.== 不用编辑->进行操作->状态转移方程
                  != 要编辑->进行操作->状态转移方程

        5.5.回文
            1.连续回文
                  P647 P5
            2.不连续回文
                  P516
            3.区别
                  if(s[i]!=s[j]) 连续回文默认[i,j]不是回文；不连续回文选择忽略s[i]或者s[j]，继续找回文

## DBUG ##
    1.做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。
    2.然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。
    3.如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。
      如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。
    这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了