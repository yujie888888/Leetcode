*** DFS ***
    dfs是可一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（换方向的过程就涉及到了回溯）。
    正是因为dfs搜索可一个方向，并需要回溯，所以用递归的方式来实现是最方便的。
    某些情况下，dfs就是回溯

** Steps **
    1.确认递归函数，参数
        void dfs(参数)
            在写递归函数的时候，发现需要什么参数，再去补充就可以。
            一般情况，深搜需要二维数组数组结构保存所有路径，需要一维数组保存单一路径，
            这种保存结果的数组，我们可以定义一个全局变量，避免让我们的函数参数过多。
            例如：
            vector<vector<int>> result; // 保存符合条件的所有路径
            vector<int> path; // 起点到终点的路径
            void dfs (图，目前搜索的节点)
    2.确认终止条件
        终止条件很重要，之所以容易死循环，栈溢出等等这些问题，都是因为终止条件没有想清楚。
        if (终止条件) {
            存放结果;
            return;
        }
    另外，很多dfs写法，终止条件写在了下面dfs递归的逻辑里;也就是不符合条件，直接不会向下递归。。
    3.处理目前搜索节点出发的路径
        一般这里就是一个for循环的操作，去遍历目前搜索节点所能到的所有节点。
        for (选择：本节点所连接的其他节点) {
            处理节点;
            dfs(图，选择的节点); // 递归
            回溯，撤销处理结果
        }
    4.总结
        void dfs(参数) {
            if (终止条件) {
                存放结果;
                return;
            }
            for (选择：本节点所连接的其他节点) {
                处理节点;
                dfs(图，选择的节点); // 递归
                回溯，撤销处理结果
            }
        }
** Time Complexity **
    递归的时间复杂度：递归深度*每次递归调用的时间复杂度
    用二叉树来表示：二叉树的结点数

** Space Complexity **
