** BackTracking **
    回溯是一种通过试错的方法来解决问题的算法，纯暴力搜索方法，尤其是在搜索问题中寻找所有（或部分）解的场景，
    当它通过尝试可能的完成路径发现现有的部分解不可行时，它会撤销上一步甚至是几步的计算，再通过其他可能的分支继续尝试。
    回溯和递归最大的区别就是回溯是在递归操作之后，回溯会撤销上一步操作
    回溯法很难，很不好理解，而且回溯法并不是什么高效的算法。(md没一点好处)
* case *
        回溯法，一般可以解决如下几种问题：
            1.组合问题：N个数里面按一定规则找出k个数的集合
            2.切割问题：一个字符串按一定规则有几种切割方式
            3.子集问题：一个N个数的集合里有多少符合条件的子集
            4.排列问题：N个数按一定规则全排列，有几种排列方式
            5.棋盘问题：N皇后，解数独等等
* Steps *
        1.!!最重要的是要会画树!!
              回溯法解决的问题都可以抽象为树形结构，做题前先画一个树结构
              集合的大小就构成了树的宽度，递归的深度就构成了树的深度。
        2.返回值以及参数
            回溯算法中函数返回值一般为void。
            回溯算法需要的参数不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。
        3.回溯函数终止条件
            if (终止条件) {
                存放结果;
                return;
            }
        4.回溯搜索的遍历过程
            for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
                处理节点;
                backtracking(路径，选择列表); // 递归
                回溯，撤销处理结果
            }
        5.总结
            void backtracking(参数) {
                if (终止条件) {
                    存放结果;
                    return;
                }
                for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
                    处理节点;
                    backtracking(路径，选择列表); // 递归
                    回溯，撤销处理结果
                }
            }

##分类总结##
    #组合问题#
        P77
        P216
        P17
        P39
        P40
    #分类
        *1.resL是unique的，nums中的每个元素有无限个，nums中的元素是distinct的（P39）
            -实现 unique resL：forloop(这一层可选的元素){}
            -实现可选择无限个数的某个元素：pass in start = i
        *2.resL是unique的，nums中的每个元素只有一个，nums中的元素会重复（P40）
            -实现 unique resL：
                在P39中避免duplicate resL的方法是用forloop(这一层可选的元素)，直接避免同一层会选择相同的元素从而造成duplicate的resL (其实因为P39的元素是unique的所以这个forloop没有实现这个功能)
                但是在P40中，element 会重复，为了避免出现同样的resL：
                    先Arrays.sort(nums)
                    再forloop(num in nums){ if nusm[i] == nums[i-1] 说明这一层选择num[i]的情况前面出现过了，直接pass }
            -实现 每个元素只能用一次：
                pass in start=i+1 (这个还实现了避免重复resL的作用，unique resL的实现其实就是在这个基础上加了个nums[i]?nums[i-1]的判断)
       *3. unique resL && 规定层数为k && nums中的每个元素只有一个, nums中的元素是distinct的（P216）
            P40的简单版
            -unique resL：forloop(i:satrt->n){}
            -实现 每个元素只能用一次：start = i+1;

       *4. non-unique resL && nums中的元素可用多次 && nums中的元素是distinct的（P377）
            -non-unique resL：forloop(i:0->n){}
            -实现 每个元素用多次：start = 0;
            这道题用BT超时，可以用DP做

    #分割问题#
        P131
        P93
    #Subsets#
        P78
        P90
    #Subsequences#
        P491

** Time Complexity **
    !!最重要的是要会画树!!
    递归树的宽度^递归树的深度 * 单层语句的时间复杂度(在每个结点进行的操作的时间复杂度)
    或者说 树的结点数量 * 单层语句的时间复杂度(在每个结点进行的操作的时间复杂度)
** Space Complexity **
    递归栈深度 + 结果存储空间
        在递归过程中，每一层递归都会在调用栈上占用一定的空间。这通常包括函数参数、局部变量和返回地址。
##题型Topic##
    1.Combinations
      1.单层递归中遍历每一层可以的选择
      2.用BackTracking递归每一层(剪枝操作一般在这)
      3.终止条件处进行结果处理