/***Java Core***/
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/** Java Version **/
    我用过的：
        java 17 java 21
    Java8
        1. Lambda Expressions
           允许将函数作为方法参数, 使代码更简洁 Allows functions as method parameters, making the code more concise(kənˈsīs).
           例如: `(a, b) -> a + b`
        2. Method references
           直接引用已有的方法 Directly reference existing methods
           Types:
                静态方法引用: 类名::静态方法名
                实例方法引用: 对象::实例方法名
                对象方法引用: 类名::实例方法名
                构造方法引用: 类名::new
           例如: `String::toLowerCase`
        3. Stream API:(看起来好好用啊，准备学)
           它允许以声明式方式处理数据集合，简化了集合处理代码；并且Stream API还支持并行操作,从而提高了大数据集处理的效率
           It allows processing data collections in a declarative way, simplifying the collection processing code;
           and the Stream API also supports parallel operations, improving the efficiency of processing large data sets.
           例如: `list.stream().filter(n -> n > 10).collect(Collectors.toList())`
        4. Optional Class:
           Use a better way to handle null value, handle NullPointerException。
        5. Default Method:
           允许在接口中定义默认实现。
        6. FunctionalInterface:
           只有一个抽象方法的接口,可以用 @FunctionalInterface 注解。
        7. Nashorn JavaScript Engine:
           Allows run specific javascript applications on the JVM
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/** JDK vs JRE vs JVM **/
JDK > JRE > JVM
在开发阶段，你需要JDK；在部署和运行阶段，只需要JRE  Deployment and operation phase

Java Development Kit:
         JDK is the Java Development Kit, which contains the tools needed to develop and compile Java programs, including JRE to run Java programs.
         JDK 是一个完整的开发工具包

Java Runtime Environment:
        JRE is the environment for running Java applications. It contains the libraries, Java Virtual Machine (JVM), and other supporting files required to run Java programs.
        JRE 包括 JVM 和 library

Java Virtual Machine:
        JVM is responsible for translating Java bytecode into machine code in order to execute Java programs on a specific platform.
        JVM 只是执行引擎
        JVM 始终是 JDK 和 JRE 的一部分
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/** OOP **/
    Object Oriented Programming
    [Driven by object] It is a programming mechanism that is driven by object.
    Concepts
        1.Encapsulation
            隐藏类的内部实现细节；Hide the internal implementation details of the class
            将数据（属性）和行为（方法）捆绑在一起；Bundle data (attributes) and behavior (methods) together;
            通过访问修饰符（public, private, protected, default）来控制对类成员的访问；Control access to class members through access modifiers (public, private, protected, default);
            提供公共方法（通常是getter和setter）来访问和修改私有数据。
            实现了：数据的安全性和完整性；代码的模块化和可维护性；降低了系统的复杂性
            Achieved: data security and integrity; code modularity and maintainability; reduced system complexity
        2.Inheritance
            inheritance means one class derives from another class and acquires all the properties and functionality(except private val method) of the derived class
        3.Polymorphism
            An object has multiple states. polymorphism has two main forms： static polymorphism and dynamic polymorphism. static-overload dynamic-override.
            Overload happens when a class or interface defines multiple methods with the same name but different parameters.
            override is happens when a subclass inherits from a superclass. which allowing the subclass to override the method from the superclass and implements its unique functionality."
            分类:
                静态多态
                    也称为方法重载Overload
                动态多态
                    也称为方法重写Override
        4.Abstraction
            Focus on hiding complex implementation details and only presenting necessary, high-level functional interfaces to users
            Implement from abstract class or interface, they defined the behavior of objects and dont need to achieve implement details.
            通过使用抽象类和接口来实现的，这些类和接口描述了对象的行为，而不需要完全实现所有的功能
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/** Class VS Object **/
Definition:
        A class is a blueprint or template for creating objects. It defines the structure and behavior that the objects of that class will have.
        An object is an instance of a class.
Memory Allocation:
        Class: Classes don't occupy memory when defined. They are just templates.
        Object: Objects are allocated memory when they are created (instantiated).
Existence:
        Class: Exists throughout the program's execution.
        Object: Can be created and destroyed during program execution.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/** Access Modifier **/
public          公共方法，可被任何对象访问
protected       受保护的方法，只能被同一个包内的类或子类访问access；子类可以访问父类中声明为 protected 的成员， 而不管子类与父类是否在同一包中。
private         私有方法，仅在类内部使用
default         只有同一包中的类可以访问

                Ex.
                    class BankAccount {
                        // 私有属性，外部代码不能直接访问
                        private double balance;
                        // 构造函数，用于创建账户实例并初始化余额
                        public BankAccount(double initialBalance) {balance = initialBalance;}
                        // 公共方法，允许外部代码存款
                        public void deposit(double amount) {...}
                        // 公共方法，允许外部代码取款
                        public void withdraw(double amount) {...}
                        // 公共方法，允许外部查询当前余额，但不能直接修改它
                        public double getBalance() {return balance;}}
                        BankAccount 类通过其公共接口（方法）暴露功能，而内部实现细节（如余额如何改变）以及数据余额则被隐藏。
                        这样，外部代码只需关心如何使用这些公共方法，而不用担心这些方法背后的具体逻辑是如何实现的。
                        封装的真正力量在于它能够防止外部代码“直接”访问和修改内部状态。
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/** Interface **/
    What is:
        接口是一个完全抽象的类fully abstract class，The interface only defines a set of method signatures, doesn't provide the implementation details.
        接口是定义一套规范的方式，它告诉实现它的类必须实现哪些方法The interface dictates which methods must be implemented by the classes that implement it.
    Feature
        当一个类实现一个接口时，这个类被要求实现接口中的所有抽象方法.
        接口中的方法默认是public和abstract的，即使没有显式地标注为abstract
        实现一个接口中的抽象方法时，必须要严格按照抽象方法的定义来实现。这包括参数的数量、类型，以及返回值类型都必须与接口中抽象方法的定义一致
        It must be implemented strictly according to the definition of the abstract method
    Java 8
        java8之后，接口中可以有默认实现default method和静态方法static method
            default method
                允许在接口中提供方法的具体实现
                允许向现有的接口添加新功能,而不需要修改所有实现类
                实现类可以选择使用默认实现或Override该方法
                如果一个类实现了多个接口,且这些接口有相同的默认方法,则该类必须Override这个方法来解决冲突
            static method
                方法属于接口本身,不属于实现类
                不能被实现类继承或Override
                通过接口名直接调用,不需要实例
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/** Functional interface **/
    What is:
        Functional interfaces have one and only one abstract method;
        In Java 8, they can contain default methods and static methods.
            1.默认方法是接口中带有默认实现的方法，它们使用default关键字标记。默认方法允许开发者在不破坏已有代码的情况下，向接口添加新的功能，因为已经实现该接口的类不需要强制覆盖这些方法。
              Default methods allow developers to add new functionality to an interface without breaking existing code, because classes that already implement the interface do not need to override default methods.
            2.接口的静态方法可以被接口直接调用，不需要一个接口的实例，且不能被实现该接口的类或者对象所调用
              Static methods of an interface can be directly called by f-interface without an instance, and they cannot be called by classes or objects that implement the interface.
    一般都有 @FunctionalInterface 这个标注
    Ad:
        函数式接口是 Lambda 表达式的基础。Lambda 表达式本质上是这些接口的一种简洁实现方式
        替代了大量的匿名内部类，使代码更加简洁易读
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/** Abstract class **/
    What is: 抽象类是用来捕捉子类的通用特性的类。它不能被实例化instantiated，只能被其他类继承。抽象类可以包含具体实现的方法和抽象方法。
             An abstract class is a class used to capture the common features of subclasses.
             It cannot be instantiated and can only be inherited by other classes.
             An abstract class can contain concrete implementation methods and abstract methods.
    特点：
        包含构造方法：抽象类可以有构造方法，这些构造方法在子类实例化时被调用。
        可以包含已实现的方法：抽象类可以包含已实现的方法（具体方法），也可以包含抽象方法（没有实现体的方法）。
        支持成员变量：抽象类可以有成员变量，这些变量可以是非静态的，也可以是静态的。
        继承限制：一个类只能继承一个抽象类，因为Java不支持多重继承。
-------------------------------------------------------------------
* Abstract class VS interface *
    1. An interface is a fully abstract class that defines a set of method signatures but does not implement for any method.
         Methods in the interface are default abstract, and interface can only contain constants (static final variables) and abstract methods.
       An abstract class is a class that can contain both abstract methods and concrete methods.
    2. A class can implement multiple interfaces, 实现接口的类必须提供接口中定义的所有方法
       but can only inherit from one abstract class. 继承抽象类的子类必须提供抽象类中定义的所有抽象方法的实现。
    3. 接口不能被实例化
       Abstract class也不能被实例化instantiated，通常需要子类继承并实现其中的抽象方法
    4. Methods in interfaces are public abstract by default, Variables in interfaces are public static final by default
       抽象类中的抽象方法默认是 protected 的，具体方法的访问修饰符可以是 public，protected 或 private 。
    5. Abstract class can implement an interface. But interface can’t extends an abstract class.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/** Overloading **/
    Method call is determined at compile time
    重载是指在同一个类中有多个同名方法multiple methods with the same name，但这些方法的参数列表不同（参数的数量、类型或者二者都不同）。
    重载使得你可以给多个功能相似但又不完全相同的方法以相同的名字。
    // 方法重载示例
    public class DemoClass {
        public void display(int a) {
            System.out.println("Got Integer data.");
        }
        public void display(String a) {
            System.out.println("Got String data.");
        }
    }
-------------------------------------------------------------------
/** Overriding **/
    Method call is determined at runtime
    重写是指子类subclass中定义了一个方法，该方法与父类中某个方法具有相同的名称，参数列表parameter list，返回类型return type。
    通过重写，子类能够提供一个特定实现specific implementation，覆盖override父类中提供的相同方法。Same method signature,
    重写发生在继承体系inheritance hierarchy内部，是一个运行时的概念runtime concept。
    class ParentClass {
        public void display() {
            System.out.println("Display in parent class.");
        }
    }
    class ChildClass extends ParentClass {
        // 重写 ParentClass 中的 display() 方法
        @Override
        public void display() {
            System.out.println("Display in child class.");
        }
    }
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/** Constructor **/
    [initialize a class object] Constructor is used to initialize an object of a class.
    Features:
        [Same name with class] It has the same name as the class.
        [No return type] it has no return type
        [Automatic calling] When an object is created by the new keyword, the constructor is automatically called.
        允许有多个有参构造器，也就是构造器也存在重载
        如果没有在类中显式定义任何构造函数，Java 编译器将为类提供一个没有参数的默认构造函数。一旦你定义了任何构造函数，这个默认的构造函数就不会自动提供。
    2 types of constructor
        Default type: without any params, i.e. public Person() {}
        Parameterized type. E.g. public Person(int age, String name) {}
* 构造方法能不能重写 *
    构造方法不能重写。因为构造方法需要和类保持同名，而重写的要求是子类方法要和父类方法保持同名。
    如果允许重写构造方法的话，那么子类中将会存在与类名不同的构造方法，这与构造方法的要求是矛盾的。
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/** static Keyword **/
What is: The static keyword in Java is mainly used for memory management.
         The member that modified by static keyword belongs to the class rather than an instance of the class.
         These members can share same variable or method of a given class.
         can apply static keywords with variables, methods, blocks, and nested classes.
Features:
         Static variables and methods are allocated memory space only once during the execution of the program.
         Static members can be accessed without the need to create an instance of the class.
         Static methods and variables cannot access non-static members of a class
         Can be overloaded, but not overridden.
Advantages:
         Memory efficiency: Static members are allocated memory only once during the execution of the program
         Improved performance: Because static members are associated with the class rather than with individual instances, they can be accessed more quickly and efficiently than non-static members.
         Encapsulation of utility methods: Static methods can be used to encapsulate utility functions that don’t require any state information from an object. This can improve code organization and make it easier to reuse utility functions across multiple classes.
Types:
    Static blocks
         static block gets executed exactly once
    Static variables
         static variables are shared among all objects at the class level.
         can only create static variables at the class level.
    Static methods
          can only directly call other static methods.
          can only directly access static data.
          cannot refer to 'this' or 'super' in any way.
    Static Classes
          can declare nested classes as static.
          cannot declare a top-level class with a static modifier
---------------------------------------------------------------------
* static修饰的ArrayList能不能添加元素 *
         static修饰的ArrayList可以添加元素.
         static确保所有Class的对象共享同一个ArrayList对象,对这个ArrayList的任何修改都会影响到所有使用这个类的地方.
         但是ArrayList对象本身是可变的,它的方法（如add()）仍然可以被调用
---------------------------------------------------------------------
* Can we use 'this' keyword in static methods *
         we cannot use the 'this' keyword in static methods.
         Because 'this' refers to the current instance of the class. It's used to differentiate between instance variables and parameters with the same name.
         and Static methods belong to the class itself, not to any specific instance of the class.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/** final keyword **/
    当final用于修饰变量时 When final is used to modify a variable
        当final修饰基本类型变量时，该变量的值在初始化后就不能再改变
        当final修饰引用类型变量时，该变量不能重新指向其他对象，但是所指向的对象的内容可以改变
        The variable cannot be re-pointed to another object, but the content of the object it points to can be changed.
    修饰方法:final方法不能被子类重写(override)
    修饰类:final类不能被继承
---------------------------------------------------------------------
* final vs static *
    当 final 用于修饰变量、方法或类时，表示它是不可变的。对于变量，一旦赋值后就不能再修改;对于方 法，表示方法不能被子类重写;对于类，表示类不能被继承。
        When final is used to modify a variable, method, or class, it means that it is immutable.
            For variables, once assigned a value, it cannot be modified;
            for methods, it means that the method cannot be overridden by a subclass;
            for classes, it means that the class cannot be inherited.
    static 用于修饰成员时，该成员成为类级别的，而不是实例级别的。静态成员属于类，而不是属于类的instance
        When static is used to modify a member, the member becomes class-level rather than instance-level.
        Static members belong to the class, not to the instance of the class.
---------------------------------------------------------------------
* Final vs Finally vs Finalize() *
    final:
        [Reserved keyword] It is a reserved keyword in Java.
        When final is used to modify a variable, method, or class, it means that it is immutable.
            [class] A final class can’t be inherited
            [method] A final method can’t be overridden
            [variable] A final variable value can’t be re-set.
    finally:
        [Used with java exception] It is used in java exception handling, and can only be used in try/catch.
        [Always being executed] always be executed no matter if the exception is handled or not.
    finalize:
        a method of java.lang.Object; 每一个对象都有这个方法; perform cleanup method before objects are being destroyed
        一个对象的finalize方法只会调用一 次，调用了不一定被回收，因为只有对象被回收的时候才会被回收，就会导致前面调用，后面回收的时候出现问 题，不推荐使用
---------------------------------------------------------------------
* abstract class 和 interface可不可以用final *
abstract class and interface 和 final 关键字不能一起使用
    abstract class and interface 的目的是被继承和扩展 The purpose of abstract classes is to be inherited and extended
    final类的目的是防止被继承 The purpose of a final class is to prevent inheritance
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/** this keyword **/
Features:
        this不能在静态上下文中使用,因为静态成员属于类,而不是对象。
        在构造函数中,this()调用必须是第一条语句。
        this关键字主要用于消除歧义和提高代码的可读性

1.区分局部变量和实例变量:
        当方法或构造函数的参数名与实例变量名相同时,this可以用来消除歧义 Distinguish different variables with the same name
        public class Person {
            private String name;

            public Person(String name) {
                this.name = name; // 'this.name' 指的是实例变量, 'name' 指的是参数
            }
        }
2.在构造函数中调用其他构造函数:
        this可以用来从一个构造函数调用同一个类的另一个构造函数
        妙啊
        public class Person {
            private String name;
            private int age;

            public Person(String name) {
                this(name, 0); // 调用另一个构造函数
            }

            public Person(String name, int age) {
                this.name = name;
                this.age = age;
            }
        }
3.返回当前类的实例
        this可以被用作方法的返回值,通常用于方法链
        public class Builder {
            public Builder addElement(String element) {
                // 添加元素的逻辑
                return this; // 返回当前对象,允许方法链
            }
        }
        // 使用: new Builder().addElement("A").addElement("B");
4.将当前对象作为参数传递
        this可以作为参数传递给其他方法
        public class Person {
            public void greet(Greeter greeter) {
                greeter.greet(this);
            }
        }
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/** Shallow copy vs Deep copy **/
浅拷⻉:
    创建一个新对象,然后将原始对象的非静态字段复制到新对象。
        如果字段是值类型的,则复制值。
        如果字段是引用类型的,则复制引用但不复制引用的对象。
深拷⻉:
    创建一个新对象,递归地复制原始对象中的所有字段。
    是一个完全独立的对象副本,避免了共享引用带来的副作用
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/** anonymous inner class **/
    Definition: 匿名内部类定义在方法里或者构造器内的类，是一种特殊的局部内部类,匿名内部类不需要为这个类声明名字
    Advantages: 匿名内部类用于更方便的创建一个子类和子类对象
    Use case: 作为一个参数parameter传递给方法
    Ex：
        public class Test{
            public static void main(String[] args){
                // 如果想使用Animal类的cry方法，本来是一定要create subclass然后implement cry()的
                // 但是这里使用anonymous inner class就可以直接跳过subclass使用cry()
                // 1.This anonymous inner class will be compile into a subclass
                // 2.Immediately create an object of subclass
                // So this class is not only a subclass but also an object
                new Animal(){
                    @Override
                    public void cry(){
                        System.out.println("cry");
                    }
                }
                // So you can Animal a = new Animal(){...}
                // Use object to invoke cry(); a.cry();
            }
        }
        abstract class Animal(){
            public abstract void cry();
        }
-------------------------------------------------------------------
/** Lambda **/
    JDK8开始新增的一种语法形式，用于简化anonymous inner class的写法
    Ex:
        原写法：
            Arrays.sort(strs,new Comparator<String>(){
                        @Override
                        public int compare(String a, String b){
                            String order1 = a + b;
                            String order2 = b + a;
                            return order2.compareTo(order1);
                        }
                    });
        Lambda写法：
            // (被重写方法的形参列表) -> {被重写方法的方法题代码}
            Arrays.sort(strNums, (String a , String b) -> { return (b + a).compareTo(a + b);} );
            // Lambda简化写法
            Arrays.sort(strNums, (a, b) -> (b + a).compareTo(a + b));
                1.参数类型可以不写
                2.如果只有一个参数，可以不写()
                3.如果方法体只有一行代码，可以不写{},同时要省略;分号
                4.同时如果这行方法体是return语句，可以省略return
        注意事项：
            Lambda不能简化所有anonymous inner class的写法，只能"简化函数式接口"的anonymous inner class
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/** Collection **/
    是一个泛型接口，表示单列集合
    * sub-interface *：
        1.List<E>
            特点：
                添加的元素是有序的、可重复的、有索引的
                Maintain the element in the insertion order, can be repeated, and have indices.
            实现类：
                ArrayList<E>
                LinkedList<E>
        2.Set<E>
            特点：
                添加的元素是无序的、不重复的、无索引的
                The added elements are unordered, non-repeating, and unindexed
                但是实现类LinkedHashSet<E>和TreeSet<E>是有序的
            实现类：
                HashSet<E>  无序、不重复、无索引  HashSet<String> set = new HashSet<>();
                    LinkedHashSet<E>   有序、不重复、无索引
                TreeSet<E>  按照大小默认升序排序、不重复、无索引
        3.Queue<E>
            很多实现类既实现类List接口，又实现类Queue接口，如LinkedList
            ArrayList就没有实现Queue接口
            PriorityQueue也没有实现List接口
            Deque
                Deque接口继承自Queue
    * Collection常用方法 *
        这些方法List<>和Set<>都能用
        .add(E e)   添加元素
        .clear()    清空元素
        .isEmpty()  判断集合是否为空
        .size()     获取集合大小
        .contains(Object obj)   判断集合中是否包含元素obj,区分大小写
        .remove(E e)   删除某个元素,如果有多个重复元素，默认删除前面的第一个
        .toArray()  把集合转换成数组
        c1.addAll(c2)           把集合c2的内容倒入另一个集合c1中,也就是c1原来的数据+c2的数据。这两个集合的数据类型需要是一样的
    * Traversal *
        1.iterator迭代器
            专门用来遍历collection的专用方式
            iterator语法
                .iterator()         获取iterator
                boolean hasNext()   询问当前位置是否有元素存在，存在return true
                .next()             获取当前位置的元素，并同时将迭代器对象指向下一个元素处
            iterator_Ex.
                Collection<String> c = new ArrayList<>();
                while(c.hasNext()){
                    System.out.println(c.next());
                }
        2.for-each
            既可以用来遍历collection，也可以来遍历数组
            语法
                for(Type value_name : array(Collection)){}
        3.Lambda Expression
            JDK8新特性
            语法
                default boid forEach(Consumer<? super T> action)
            Ex.
                Collection<String> c = new ArrayList<>();
                //原写法
                c.forEach(new Consumer<String>(){
                    @Override
                    public void accept(String s){
                        System.out.println(s);
                    }
                });
                //用Lambda写法
                c.forEach(s -> System.out.println(s));
                //写成上面这样就可以了，下面这个对我的水平来说超纲了
                //前后对象一样，继续简化  ::表示引用  这个对象引用println这个方法
                c.forEach(System.out::println);
-------------------------------------------------------------------
* List vs Set *
    They are implementation classes of Collection interface.
    List maintain the element in the insertion order, can be repeated, and have indices.
    Set,no any order,can not be repeated, have no indices
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/** List **/
    主要实现类
        ArrayList
            基于动态数组实现
            随机访问元素的速度很快（常数时间复杂度） list.get()
            在列表末尾添加元素通常很快 list.add()
            在列表中间插入或删除元素较慢，因为需要移动其他元素
            使用无参constructor构造的ArrayList会默认创建一个长度为0的array List<String> list = new ArrayList<>();
            添加第一个元素时，会创建一个新的长度为10的数组；存满时，会扩容1.5倍
            如果批量添加元素(.addAll())，会创建一个对应长度的数组
        LinkedList
            基于双向链表实现,使用节点来存储元素，每个节点包含一个数据元素和两个指针，分别指 向前一个节点和后一个节点
            随机访问元素较慢，因为需要遍历链表
            在列表的开头和结尾添加/删除元素的速度很快（常数时间复杂度）
            在列表中间插入/删除元素也相对较快
            LinkedList对首尾操作的方法
                .addFirst(E e)  在开头插入指定元素
                .addLast(E e)   在末尾插入指定元素
                .getFirst()     返回第一个元素
                .getLast()      返回最后一个元素
                .removeFirst()  删除第一个元素并返回这个元素
                .removeLast()   删除最后一个元素并返回这个元素
                indexOf(Object o): 返回指定元素首次出现在链表中的索引。
                lastIndexOf(Object o): 返回指定元素最后一次出现在链表中的索引
            LinkedList使用场景
                设计queue队列(先进先出)
                设计stack栈(后进先出)
                    List<Integer> stack = new LinkedList<>();
                    //push
                    stack.addFirst(1);
                    stack.addFirst(2);
                    stack.addFirst(3);
                    //pop
                    System.out.println(stack.removeFirst());
                    //输出是1 2
        Vector
            类似于ArrayList，所有方法都是同步的，保证线程安全
            性能比ArrayList稍差，因为有同步开销
            Stack
                继承自Vector，实现了后进先出（LIFO）的栈
                线程安全的
    常用方法
        List<Integer> list = new ArrayList<>();     创建List，经常用到，推荐这么写
        .add(int index, E e)                        插入元素,void
        .remove(int index)                          删除元素,并返回被删除元素(用不用这个元素看场景)
        .get(int index)                             返回指定元素
        .set(int index,E e)                         修改特定位置处的元素，修改成功后会return原来的数据
    遍历方法
        for()
        for-each()
        iterator
        forEach() Lambda
-------------------------------------------------------------------
* Array vs Arraylist *
1. size
    For array, when create array, You must specify the size of the array.
    ArrayList是动态数组实现的，它的大小可以动态增⻓或缩小;在不断添加元素时，ArrayList 会自动进行扩容As elements are added, ArrayList will automatically expand.
        But you can also specify the size, which is the initial capacity of the ArrayList
2.generics
    数组可以存储任何类型的元素，但不支持泛型。
    ArrayList:支持泛型，可以指定存储的元素类型
3.store type
    Array can directly store basic data types and Object
    ArrayList 中只能存储对象。对于基本类型数据，需要使用其对应的包装类(如 Integer、Double 等)
4. modify content
    ArrayList has multiple method to modify the content
-------------------------------------------------------------------
* ArrayList vs LinkedList *
    Common：
        They are both implementation classes of List interface
        有序、可重复、有索引
    Diff：
        1.Underlying implementation
            ArrayList是基于动态array实现的，数据是内存中的一块连续区域 Underlying implementation uses an array which is a continuous memory.
            LinkedList是基于双链表实现的
                Underlying implementation uses double linked list which is not continuous memory.
                Use nodes to store elements.
                Each node contains a data element and two pointers, pointing to the previous node and the next node respectively.
        2.access speed
            ArrayList: Supports fast random access and traversal because elements can be accessed directly by index.
            LinkedList: Random access performance is poor because traversal must start from the head or tail of the linked list until the target index is reached.
        3.add and delete speed
            ArrayList: 在末尾进行插入和删除操作是高效的，但在中间或开头插入和删除需要移动元素，性能较差
            LinkedList: Without considering the time to find the location，The performance of inserting and deleting elements is relatively good，特别是头尾插入和删除元素时
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/** Set **/
    Hash Value
        hash value 是一个int类型的数据，java中每个对象都有一个hash value
        每个对象都可以调用hashCode()方法返回自己的hash value，且hash value是固定的
        不同对象的hash value可能相同，就是Hash Collision
    HashSet
        Feature
            无序(不保证元素的顺序，因此遍历时的顺序可能是不确定的)
            不重复
            无索引
        Performance
            增删改查性能都很好,查找、插入、删除等操作的平均时间复杂度是 O(1)
        底层结构：
            其实HashSet就是基于HashMap实现的，只是Set中的元素只要了key，不要value
            允许存储一个null元素
            结构： 19:00 link->   https://www.bilibili.com/video/BV1Cv411372m?p=140&spm_id_from=pageDriver&vd_source=db36d19643c35aa99685934506516717
                JDK 8之前
                    hash table = array + linkedlist
                JDK 8之后
                    hash table = array + linkedlist + red black tree
                    解决链表过长，导致查询性能降低这个问题
                    当linkedlist长度超过8，且array长度超过64，自动将linkedlist转成红黑树
        LinkedHashSet
            有序、不重复、无索引
            有序是因为，每个元素都额外多了一个双链表的机制，记录该元素的前后元素的位置
            基于hash table实现
    TreeSet
        排序、不重复、无索引
        排序通过红黑树实现排序
        对于基本数据类型int double等，按照数值大小进行升序排序
        对于自定义类型，无法直接排序
            所以treeset在存储自定义类型的对象时，必须指定排序规则
                1、让自定义的类实现Comparable接口，实现里面的compareTo方法来指定比较规则
                    class Student implements Comparable<>{
                        @Override
                        compareTo(){...}
                    }
                    a.compareTo(b){}
                        如果认为a>b，返回正整数；如果认为a<b，返回负整数；如果认为a=b，返回0；
                        所以override compareTo方法就是写怎么return来告诉怎么排序
                2、通过调用treeset集合有参构造器，通过anonymous_inner_class，将Comparator对象作为参数传入treeset
                    TreeSet(Comparator<? super E> comparator)
                    Set<Student> student = new TreeSet<>(
                        new Comparator<Student>(){
                            @Override
                            public int compare(Student d1,Student d2){
                                return Double.compare(d1,d2);//对于double类型，直接调用Double.compare方法就会返回整数，因为compare要求返回整数
                                //如果d1>d2,那么返回1，也就是告诉compare，d1排在d2后面
                            }
                        });
                        //用Lambda简化
                        Set<Student> student = new TreeSet<>((d1,d2) -> Double.compare(d1,d2));
-------------------------------------------------------------------------------------
* HashSet vs LinkedHashSet vs TreeSet *
    HashSet is non-order, non-repeated, non-index
    LinkedHashSet is inherited from HashSet class, use linkedlist to maintain the insert order of elements
    TreeSet base on red black tree, the element in it according to Ascending order or can customize the sorting rule
-------------------------------------------------------------------------------------
* how to make hashset in the order I wanted *
1. LinkedHashSet
2. TreeSet
    default order
    customize sorting order
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/** Map **/
    双列集合(键-值对)接口
    * Main implement class *
        HashTable
        HashMap<K,V>    无序、不重复、无索引
            LinkedHashMap<<K,V>     有序、不重复、无索引
        TreeMap<K,V>    按照大小升序排序、不重复、无索引
    * 常用方法 *
        Map<Integer,Integer> map = new HashMap<>()  创建HashMap
        map.size()                                  集合大小
        map.clear()                                 清空map
        map.isEmpty()                               判断是否为空
        map.get(key)                                获取key对应的值，如果key存在返回值，如果key不存在返回null
        map.remove(key)                             删除整个键值对，并返回删除的key的balue
        map.containsKey(key)
        map.containsValue(value)
        map.keySet()                                获得map的所有key，用set()返回
        map.values()                                获得map的所有value，用collection返回
        map.pullAll(map2)                           把map2的内容倒进map中，map的元素就变多了。如果map和map2有重复key，那么map2key的value 覆盖 map key的value
    * map travesal method *
        1、获取key，遍历key
        2、Lambda遍历(JDK8新出现的，非常简单)
            模板
                default void forEach(BiConsumer<? super K, ? super V> action)
            Ex.
                Map<String, Double> map = new HashMap<>();
                map.forEach((k,v) -> System.out.println(k + "->" + v));//这个方法直接用,已经是一种固定写法了
    * HashMap *
        underlying implementation:
            基于Hash Table实现,HashTable
                HashTable 是早期 Java 类库中提供的类，它实现了 Map 接口并继承自 Dictionary 类
                HashTable 是线程安全的，所有的方法都是同步的，即它是线程安全的集合类
            structure/ construction
                每个array元素称为 a bucket
                Java8之前
                        hash table = array + linkedlist
                Java8之后
                        hash table = array + linkedlist + red black tree
                        当一个桶中的元素超过某个阈值（默认是 8）并且 HashMap 的容量大于 64 时，链表会转换为红黑树;当红黑树的节点数量减少到 6 时，会转换回链表。
                        链表查找的时间复杂度是 O(n)，其中 n 是链表长度
                        红黑树查找的时间复杂度是 O(log n)，显著优于长链表
        LinkedHashMap
            有序
    * HashTable *
        similar as HashMap but HashTable is thread safe
        不允许null键或值：这点与HashMap不同
    * TreeMap *
        基于红黑树实现的，存储元素时按照元素的自然排序或者指定的比较器排序
        不允许存储 null 元素
        查找、插入、删除等操作的平均时间复杂度是 O(log n)
---------------------------------------------------------------------
* HashMap how to add an element *
    1. 计算键的哈希码。
    2. 将哈希码映射到数组索引。
    3. 如果该索引位置为空
            直接插入
       如果该位置已有元素：
            比较键是否相等，如果相等则更新值
            如果不相等，则将新元素添加到链表/树中
---------------------------------------------------------------------
* HashMap how to handle collision *
冲突产生的原因：
    当两个不同的键通过哈希函数映射到同一个桶时，就会发生冲突。
冲突解决策略：
    Chaining
        Java 8之前：
            每个桶都是一个链表的头;当发生冲突时，新元素被添加到链表的末尾。
        Java8之后：
            引入了红黑树来优化长链表
            当一个桶中的元素超过某个阈值（默认是 8）并且 HashMap 的容量大于 64 时，链表会转换为(converted into)红黑树,将元素作为node of tree
---------------------------------------------------------------------
** HashMap VS HashTable **
1.thread safe
    HashTable 是线程安全的，所有的方法都是同步的；
    HashMap 不是线程安全的，多线程环境下使用 HashMap 需要额外的同步措施。但是 HashMap 的性能更好。
2.
    HashTable 不允许键和值为 null，如果试图插入 null 键或值，将抛出 NullPointerException 异常。
    HashMap 允许键和值为 null
---------------------------------------------------------------------
** HashMap VS HashSet **
Both HashMap and HashSet are not thread-safe
1. interface
    HashSet implements the Set interface
    HashMap implements the Map interface
2.store
    HashSet stores single column element
    HashMap stores key & value pairs
3.duplicate elements
    HashSet doesn't support duplicate elements
    HashMap doesn't support duplicate key but support duplicate value
4.null value
    HashSet permits to have a single null value.
    HashMap permits single null key and any number of null values.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/** Hash **/
    * Hash Function *
        概念
            是一种从输入数据(key)到固定大小的数值(Hash value)的映射
        设计原则
            确定性：相同的输入总是产生相同的输出。
            高效计算：散列函数的计算过程应当高效快速，以便能够迅速处理大量数据。
            均匀分布：理想的散列函数应该将任何一组输入均匀分布到所有可能的散列值上，以减少碰撞（两个不同输入值产生相同散列值的情况）。
            抗碰撞性（对于加密散列函数）：对于任意已知的输出，应该计算上不可行找到对应的输入（即单向性）。
        应用
            Hash Tables
                散列函数用于散列表中，是实现快速数据查找的关键。例如，Python 的字典（dict）和 Java 的 HashMap 都是基于散列表实现的。
            数据校验：
                散列函数常用于校验数据完整性。常见的用途包括验证下载文件是否损坏，或者检查数据在传输过程中是否被篡改。
            加密和安全：
                加密散列函数（如 MD5, SHA-1, SHA-256）在密码存储、数字签名、数据完整性验证中扮演着重要角色。它们帮助保证数据的机密性和完整性，防止未授权的信息访问。
            负载均衡：
                在网络服务中，散列函数可以帮助决定将客户端请求路由到哪个服务器，以均匀地分配负载。
            唯一标识：
                散列函数可以从大量数据生成短小的唯一标识，例如在大数据处理和快速数据查找中生成唯一的键值。
            随机化算法：
                散列函数在一些算法中用来保证算法的随机性和公平性，如在随机化快速排序和蒙特卡洛方法中。
    * Hash Collision *
        概念：
            Hash collision is that multiple keys are hashed to the same index.
            Hash Collision是指当两个或多个不同的键被哈希函数映射到了同一个索引或哈希码上的情况。
            这种情况在哈希表中是非常常见的，因为哈希函数将一个大的键空间映射到了一个较小的索引空间，从而导致了可能性的重叠。
        解决Hash Collision
            1.链表法（Chaining）：
                creating a linked list of entries at the index, and the new element is added to the end of the list at that index.
                每个散列槽指向一个链表。所有映射到该散列槽的元素都将存储在这个链表中。当查找、插入或删除元素时，需要遍历链表以找到目标元素。
            2.开放寻址法（Open Addressing）：
                seeks an empty slot within the hash table itself.
                当发生碰撞时，寻找另一个空的散列槽来存储这个值。常见的开放寻址技术包括线性探测、二次探测和双重散列。
        Hash Collision带来的问题
            性能降低：在散列表中，碰撞增加了查找和存储数据的时间，特别是链表法中，链表越长，性能问题越明显。
            安全隐患：在安全敏感的应用中，敌手可能利用散列碰撞来进行拒绝服务攻击（例如，通过故意创建大量碰撞来降低系统的响应能力）。
    Hash使用场景
        要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。
        需要判断一个元素是否出现过的场景也应该第一时间想到哈希法。
---------------------------------------------------------------
** Hashcode() vs equals() **
    Hashcode generating an integer type hash code for an object.
    equals compare two objects for equality and returns a boolean value.
    Note:
        If two objects are equal, then their hashCode are same.
        If their hashcode are same, it doesn't mean that they are equal.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/** Generics **/
What is：
    Allows defer specifying data type of a class, interface, or method
Types:
    generics class：
        T是一个类型参数，代表实际的类型，它将在创建Box对象时被实际的类型（如Integer、String等）替换。
        class Box<T> {
            private T t;
            public void set(T t) {this.t = t;}
            public T get() {return t;}}
    generics method：
        方法使用了类型参数T，可以接受任意类型的数组，并返回数组中间的元素
        public class Util {
            public static <T> T getMiddle(T[] a) {
                return a[a.length / 2];
            }
        }
    generics interface:
        接口使用了两个类型参数K和V，分别代表键和值的类型
        interface Pair<K, V> {
            public K getKey();
            public V getValue();
        }
    Adv:
        Java泛型是使用擦除来实现的。这意味着在编译时，所有的泛型信息都会被擦除，转换成原始类型（raw types）
        编译器会在必要的地方自动插入类型转换代码。例如，Box<Integer>和Box<String>在运行时实际上都是Box类型
        增强安全性:
            泛型提供编译时的类型检查，任何不合法的类型都会在编译期被检测出来，减少运行时的类型错误
        增强程序的可读性和稳定性
        提高了代码的重用率
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
** String **
    不可变
    线程安全：因为它的不可变性使得多个线程可以同时访问同一个字符串对象而不会发生竞争条件
-------------------------------------------------------
** StringBuffer **
    可变：它允许在同一对象上执行修改操作，而不创建新的对象
    线程安全：它的方法是同步的，可以安全地在多个线程中使用
    性能：StringBuffer 适用于在多线程环境中进行字符串操作；在单线程环境中，相比StringBuilder可能会有一些性能开销
-------------------------------------------------------
** StringBuilder **
    可变
    非线程安全：
        它的方法没有同步，因此在多线程环境中使用时需要注意同步问题
        StringBuilder 适用于在单线程环境中进行字符串操作，且通常比 StringBuffer 性能更好，因为它不需要同步
    显著减少内存的使用和提升程序性能：
        因为String对象是不可变的，每次拼接操作都会创建一个新的String对象，这在循环或频繁操作时会导致大量的内存分配和回收，增加垃圾收集器的负担。
        而StringBuilder是可变的，可以在现有的字符序列上添加或修改内容，避免了创建多余的对象。
    易用性：
        StringBuilder提供了多种方法来追加（append）、插入（insert）、删除（delete）、反转（reverse）等操作字符串，使用起来非常灵活方便。
    常用方法
        append()：
            用于向 StringBuilder 的末尾添加文本。这个方法有多个重载版本，可以接受不同类型的输入，包括 String、char、int、long、float、double 等。
            示例：sb.append("text");
        insert()：
            用于在指定位置插入文本。和 append() 方法一样，insert() 也有多种重载版本，可以插入不同类型的数据。
            示例：sb.insert(0, "start"); 在开头插入 "start"。
        charAt(int index) 和 setCharAt(int index, char ch)：
            charAt(int index) 获取指定位置的字符。
            setCharAt(int index, char ch) 设置指定位置的字符。
            示例：sb.setCharAt(0, 'N'); 将第一个字符设置为 'N'。
        delete() 和 deleteCharAt()：
            delete(int start, int end) 用于删除从 start 索引开始到 end 索引前的字符序列。
            deleteCharAt(int index) 用于删除指定位置的字符。
            示例：sb.delete(1, 3); 删除从索引 1 到索引 2 的字符。
        replace()：
            用于替换指定范围内的字符序列。
            示例：sb.replace(1, 3, "new"); 将索引 1 到 2 的字符替换为 "new"。
        toString()：
            将 StringBuilder 的内容转换为 String。
            示例：sb.toString();
        reverse()：
            将 StringBuilder 中的字符序列反转。
            示例：sb.reverse();
        length()：
            返回 StringBuilder 中的字符数。
            示例：sb.length();
        capacity()：
            返回 StringBuilder 当前的容量（即可以存储的字符数，不必进行再分配）。
            示例：sb.capacity();
        setLength(int newLength)：
            设置 StringBuilder 的长度。如果指定的长度小于当前长度，字符将被截断；如果指定的长度大于当前长度，将在末尾添加空字符。
            示例：sb.setLength(5);
-------------------------------------------------------
 ** StringBuilder vs StringBuffer **
    StringBuilder快
    StringBuffer线程安全
        线程安全：
            StringBuffer 是线程安全的thread-safe
                这意味着它的所有公共方法都是同步的，可以在多线程环境中安全使用，不会出现线程冲突thread conflict。
                StringBuffer 在内部使用 synchronized 关键字来保证线程安全。
            StringBuilder 不是线程安全的
                它的方法不是同步的，因此在多线程环境中，多个线程同时修改 StringBuilder 实例可能会导致不一致的行为或数据损坏。
                由于去除了线程同步的开销，StringBuilder 在单线程环境下通常比 StringBuffer 更快。
        性能：
            StringBuilder 通常比 StringBuffer 快，因为它避免了线程同步的开销。
        使用场景：
            如果你的应用程序需要在多线程环境中操作可变字符序列，那么使用 StringBuffer 是一个安全的选择。
            如果是在单线程环境中或者不需要考虑线程安全的情况下，推荐使用 StringBuilder，因为它提供了更好的性能。
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
* garbage collection *
    Garbage collection (GC) is a mechanism for automatic memory management.
    Garbage collector counts the references to objects. When the number of references to an object becomes 0, the collector will recycle the memory.
    Java 7 引入了 try-with-resources，以确保资源的正确关闭
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/** Exception and Error **/
* Throwable Class *
      Throwable是顶层的异常类
      Throwable 类的主要方法:
            1、public String getMessage() 返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了
            2、public Throwable getCause() 返回一个Throwable 对象代表异常原因
            3、public String toString() 使用getMessage()的结果返回类的串级名字
            4、public void printStackTrace() 打印toString()结果和栈层次到System.err，即错误输出流
            5、public StackTraceElement [] getStackTrace() 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底
            6、public Throwable fillInStackTrace() 用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中
     Throwable
         |--Error
         |  |--OutOfMemoryError
         |  |--IOError
         |--Exception
         |  |--IOException
         |  |  |--FileNotFoundException
         |  |--RuntimeException
         |  |  |--NullPointerException
* Error *
    What is:
        Error Class描述了Java运行时系统的内部错误和资源耗尽错误; Describes internal errors and resource exhaustion errors in the Java runtime system;
        Error表示比较严重的问题，一般是JVM运行时出现了错误. Error indicates serious problem, usually an error occurs when the JVM is running
    常见Error Type:
        OutOfMemoryError：JVM没有足够的内存继续执行。
        StackOverflowError：应用递归过深，栈空间耗尽。 The recursion is too deep and the stack space is exhausted
        NoClassDefFoundError：JVM 或 ClassLoader 实例尝试加载（在其路径中预先指定的）类时未找到类定义。
        AssertionError：当断言失败时抛出
* Exception *
    * RuntimeException *
        运行时才可能抛出的异常，编译器不会处理此类异常,一般是程序的逻辑有问题。
        比如数组索引越界、使用的对象为空、强制类型转换错误等等
        Array index out of bounds
        object used is null
        forced type conversion error
    * Other Exception *
        Exception中除了运行时异常之外的，都属于其他异常，也可以称之为编译时异常。
        这部分异常编译器要求必须处置，这部分异常常常是因为外部运行环境导致，因为程序可能运行在各种环境中。
        如打开一个不存在的文件，此时 抛出FileNotFoundException
    * Checked and Unchecked Exceptions *
        Checked Exceptions(Compile Exceptions):
            包括直接继承自Exception类（但不包括RuntimeException及其子类）
            这些异常在编译时必须被处理（捕获或声明抛出），否则编译器将报错；受检异常只有两种选择。要么被捕获处理，要么被声明，让调用者处理
            must be handled(required to be caught or declared at compile time) at compile time, otherwise the compiler will report an error
            例如，IOException 和 SQLException。
        Unchecked Exceptions:
            包括Error及其所有子类和RuntimeException及其所有子类
            这些异常在编译时不需要显式处理，它们通常是编程错误的结果 donot need to be handled at compile time.
            如 NullPointerException 和 IndexOutOfBoundsException。

* Exception Handling *
    throws:
        throws是用来声明异常，只要是派生于Throwable类的都可以被声明
    try-catch-finally:
        所有从Throwable派生的类都可以被catch捕获
        结构：
            a.try block
                用于包围有可能发生异常的代码。如果在 try 块内发生了异常，那么异常可以被捕获并由 catch 块处理
            b.catch block
                捕获 try 块中发生的异常，并为它们提供处理逻辑。可以有多个 catch 块来捕获不同类型的异常
                catch子句的顺序：
                    如果catch的异常类型之间没有继承关系，顺序不重要。
                    如果存在继承关系，子类异常的catch应该放在父类异常的catch之前。
                        原因：更具体的异常（子类）应该先被捕获，否则可能会被父类的catch捕获，导致处理不当
                    catch中可以为空，这样程序就会忽略掉哪些异常
                多重异常捕获：一个try块可以有多个catch子句，每个处理不同类型的异常
            c.finally block
               用来执行重要的清理操作：关闭文件流（InputStream, OutputStream)，释放数据库连接, 释放网络连接, 清理任何其他资源
                无论try块是否抛出异常，finally块中的代码都会执行;
                    这是因为编译器会讲 finally 块中的代码复制两份并分别添加在 try 和 catch 的后面
                    即使try或catch块中有return语句，finally块也会在方法返回前执行;
                    但是如果try或者catch中出现了 System.exit()语句，则会直接退出，并不会执行finally模块
            d.try-with-resources
                自Java7开始，这种结构可以自动管理资源（如文件或数据库连接），确保在try块执行完毕后自动调用资源的close()方法
        异常处理流程：
            try块中放置可能抛出异常的代码
                如果try块中的代码抛出了一个在catch子句中声明的异常
                    程序会立即跳过try块中剩余的代码
                    执行相应的catch块中的代码
                如果try块中没有抛出任何异常
                    所有的catch块都会被跳过
                如果抛出的异常类型没有在任何catch子句中声明
                    方法会立即退出，异常会被传递给上层调用者
            finally
        Ex.
            try {
                // 可能抛出异常的代码
                riskyOperation();
            } catch (FileNotFoundException e) {
                // 处理文件未找到异常
                System.out.println("File not found: " + e.getMessage());
            } catch (IOException e) {
                // 处理其他IO异常
                System.out.println("IO error occurred: " + e.getMessage());
            } catch (Exception e) {
                // 处理其他所有异常
                System.out.println("An error occurred: " + e.getMessage());
            }
        除了try-catch-finally其他方法处理exception:
            try-with-resources
            多重捕获 Multiple capture (There are multiple catch clauses)
            将异常记录到日志中 Record exceptions in the log

* 常见Exception Type *
    IOException：涉及输入输出操作失败或中断，如文件读写操作。
    SQLException：处理数据库访问错误时使用。
    ClassNotFoundException：指定的类不存在时抛出。
    InterruptedException：线程在活动之前或之中被中断时抛出。
    NullPointerException：尝试使用 null 对象引用进行操作时抛出。
    IndexOutOfBoundsException：尝试访问数组或字符串的非法索引时抛出。
    ArithmeticException：异常的算术条件，如除以零。
-------------------------------------------------------------------------------------
* Exception vs Error *
Exception 类及其子类主要用于表示程序可以处理的异常情况
    异常分为两种类型:可检查异常(Checked Exception)和不可检查异常(Unchecked Exception)
    程序员可以选择捕获并处理异常，也可以通过在方法签名中使用 throws 关键字声明方法可能抛出的异常。
Error 类及其子类通常表示虚拟机无法恢复的严重错误。
    错误不应该由应用程序捕获和处理，因为它们通常 表示虚拟机或系统本身的问题。
    一般情况下，程序员不会直接捕获和处理 Error，这些错误的发生通常意味 着程序无法继续正常执行。
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/** Assertion **/
    Assertion是一种调试辅助技术，它允许开发者在代码中设置检查点。
    只有当特定的条件（即断言）为真时，程序才会正常继续执行；如果条件为假，程序则抛出错误或异常，通常会导致程序终止
    Ex.
        public class TestAssertions {
            public static void main(String[] args) {
                int value = -5;
                assert value >= 0 : "Value must be non-negative";
                System.out.println("Value is " + value);
            }
        }
        在这个例子中，断言检查 value 是否为非负数。
        如果 value 是负数，断言将失败，并抛出一个 AssertionError，错误信息为 "Value must be non-negative"。
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
** Thread and Process**
Thread
    Thread Lifecycle:
        New
        Runnable
        Running
        Blocked
        Terminated
    Thread synchronization
        Use the synchronized keyword
        Use the Lock interface
        Use the volatile keyword
    Thread communication mechanism:
        wait(): 使当前线程等待，直到另一个线程调用notify()或notifyAll()。
        notify(): 唤醒在此对象监视器上等待的单个线程。
        notifyAll(): 唤醒在此对象监视器上等待的所有线程。
    Common Challenges
        Deadlock: 多个线程相互等待，导致CPU空闲
        Race conditions: 多个线程争夺同一资源(competing for the same resource)可能导致CPU使用率高但效率低
        Thread Starvation: 某些线程长时间得不到CPU时间
        Thread safety issues
---------------------------------------------------
* How to create a thread *
    1.Subclass the Thread class and override its run() method
      Create an instance of subclass
      Use the start() method to start the thread.
    2.Implement the Runnable interface and override its run() method
      Create an instance of subclass
      Pass this instance to the Thread constructor function
      Use the start() method to start the thread.
    3.使用Executor框架
      通过Executor ，可以将任务提交给线程池，由线程池来管理线程的生命周期和执行
---------------------------------------------------
* Threads vs Processes *
Process is the basic unit for allocating resources in the operating system
Thread is an execution unit within a process that shares the resources of the process
---------------------------------------------------
** Multithreading **
    What is: Allows the program to execute multiple independent task flows simultaneously
---------------------------------------------------
* CPU Load vs Multithreading *
    适度的线程数可以提高性能和CPU利用率 A moderate number of threads can improve performance and CPU utilization
        每个线程可以在不同的CPU核心上执行，从而并行处理任务,提高CPU利用率
    过多的线程可能导致过高的CPU负载，反而降低性能
        线程数量超过CPU核心数时,可能增加CPU负载
        When the number of threads exceeds the number of CPU cores, the CPU load may increase
    线程池
        可以通过调整线程池大小控制并发线程数,来优化CPU负载
        Can optimize CPU load by adjusting the thread pool size to control the number of concurrent threads.
    监控
        使用工具如JVisualVM可以监控线程活动和CPU使用情况
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
** volatile **
    volatile keyword used to ensure thread safe(all writes and reads will be directly on the main memory instead of cpu cache)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
** Synchronization **
    Synchronization makes sure there is only one thread that can access a resource or a block of code at a time.
    To apply Synchronization in Java：
        1、synchronized keyword.
        2、Lock interface
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
** Singleton Pattern **
    What is:
       Singleton Pattern is a common design pattern used to ensure that only one instance in the application
    Why use:
        资源共享：当多个进程需要访问相同的资源，且资源的一致状态非常重要时，单例可以确保所有的访问都通过一个实例进行。
        控制资源的访问：单例模式可以防止其他对象对其唯一实例的随意修改，从而严格控制资源。
        减少开销：如果某个实例的创建或维护成本很高，单例模式可以确保系统中只有一个实例，从而减少系统的性能开销。
        全局访问点：单例对象可以很容易地由系统的任何其他对象访问，从而方便地访问共享的资源或服务。
    Ex.
        public class Singleton {
            // 私有静态变量，保存单例实例，使用volatile保证可见性和有序性
            private static volatile Singleton instance;

            // 私有构造函数，防止外部实例化
            private Singleton() {}

            // 公共静态方法，返回唯一实例
            public static Singleton getInstance() {
                if (instance == null) { // 双重检查锁定
                    synchronized (Singleton.class) {
                        if (instance == null) {
                            instance = new Singleton();
                        }
                    }
                }
                return instance;
            }
        }
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
**  == VS .equals() **
    ==
        1. used for content comparison of primitive data types
        2. for reference comparison to check whether two references point to the same object in memory.
    equals()
        used for content comparison（except array)
            array use Arrays.equals() for content comparison
            equals.() for array is used for comparison of object memory
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
** Java Profiling **
    是一种用于分析和监控 Java 应用程序性能的技术。它帮助开发者识别性能瓶颈、内存泄漏和其他可能影响应用程序效率的问题
    It is a technology used to analyze and monitor the performance of Java applications.
    It helps developers identify performance bottlenecks, memory leaks, and other issues that may affect the efficiency of application
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
